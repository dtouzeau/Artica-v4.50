<?php
/**
 * $Id: Script.php,v 1.35 2007/09/06 15:06:20 stephengrier Exp $
 *
 * Copyright (C) 2002-2007 Stephen Grier <stephengrier@users.sourceforge.net>
 *
 * See the inclosed NOTICE file for conditions of use and distribution.
 */

// Client applications.
define("CLIENT_UNKNOWN", "unknown");
define("CLIENT_SMARTSIEVE", "smartsieve");
define("CLIENT_WEBSIEVE", "websieve");

// Test types.
define ("TEST_ADDRESS", "address");
define ("TEST_HEADER", "header");
define ("TEST_SIZE", "size");
define ("TEST_BODY", "body");

// Action types.
define ("ACTION_FILEINTO", "fileinto");
define ("ACTION_REDIRECT", "redirect");
define ("ACTION_REJECT", "reject");
define ("ACTION_KEEP", "keep");
define ("ACTION_DISCARD", "discard");
define ("ACTION_CUSTOM", "custom");
define ("ACTION_VACATION", "vacation");
define ("ACTION_ADDFLAG", "addflag");
define ("ACTION_NOTIFY", "notify");
define ("ACTION_STOP", "stop");

// Match types.
define ("MATCH_IS", ":is");
define ("MATCH_CONTAINS", ":contains");
define ("MATCH_MATCHES", ":matches");
define ("MATCH_REGEX", ":regex");

// Controls.
define ("CONTROL_IF", "if");
define ("CONTROL_ELSEIF", "elseif");
define ("CONTROL_ELSE", "else");

// Bitwise flags.
define ("CONTINUE_BIT", 1);
define ("SIZE_BIT", 2);
define ("ANYOF_BIT", 4);
define ("KEEP_BIT", 8);
define ("STOP_BIT", 16);
define ("REGEX_BIT", 128);

// Special rule identifiers.
define("RULE_TAG_FORWARD", 'forward');
define("RULE_TAG_SPAM", 'spam');
define("RULE_TAG_WHITELIST", 'whitelist');
define("RULE_TAG_VACATION", 'vacation');


/**
 * Class $this-> implements a sieve script.
 *
 * @author Stephen Grier <stephengrier@users.sourceforge.net>
 * @version $Revision: 1.35 $
 */
class SmartSieveEngine {

   /**
    * Name of script.
    * @var string
    * @access public
    */
    var $name = '';
    var $charset="utf-8";

   /**
    * UTF-8 encoded Sieve text.
    * @var string
    * @access public
    */
    var $content;

   /**
    * Script size in bytes.
    * @var integer
    * @access public
    */
    var $size;

   /**
    * Is this a script created by SmartSieve?
    * @var boolean
    * @access public
    */
    var $so = true;

   /**
    * Script mode: basic (GUI) or advanced (direct edit).
    * @var string
    * @access public
    */
    var $mode;

   /**
    * Sieve rules.
    * @var array
    * @access public
    */
    var $rules = array();

   /**
    * Client application that wrote this script.
    * @var string
    * @access public
    */
    var $client = CLIENT_UNKNOWN;

   /**
    * Version of client that wrote this script.
    * @var array
    * @access public
    */
    var $version = null;

   /**
    * Sieve extensions used.
    * @var array
    * @access public
    */
    var $extensions = array();

   /**
    * Error messages.
    * @var string
    * @access public
    */
    var $errstr;
    var $ECHO_ERROR=true;

   /**
    * Class constructor.
    *
    * @param string Script name
    * @return void
    */
    function __construct($scriptname=null,$content=null){
        $this->name = $scriptname;
        $this->content = $content;
        $this->size = 0;
        $this->so = true;
        $this->mode = 'basic';
        $this->rules = array();
        $this->errstr = '';
        $this->getContent();
    }


    // Class methods.

   /**
    * Get the script content.
    *
    * This will interpret the encoded part of the script if it exists.
    *
    * @return boolean True on success, false on failure
    */
    function getContent(){
		if($this->content==null){return array();}
        $lines = array();
        $lines = preg_split("/\n/", $this->content);
        $this->rules = array();

        // If this script was created by SmartSieve or Websieve, the first line
        // will have a recognizable format. If not, the script is of an unrecognised
        // format, and the user will be able to edit it in direct edit mode.
        $line = array_shift($lines);
        if (!preg_match("/^# ?Mail(.*)rules for/", $line)) {
            $this->so = false;
            $this->mode = 'advanced';
        } else {
            $line = array_shift($lines);
            if (preg_match("/^#Generated by ([^ ]+) using SmartSieve ([0-9])\.([0-9])\.([0-9])(-([^ ]+))? .+$/", $line, $m)) {
                $this->client = CLIENT_SMARTSIEVE;
                $this->version = array('major'=>$m[2], 'minor'=>$m[3], 'bugfix'=>$m[4],
                                       'tag'=>(isset($m[6])) ? $m[6] : null);
                $this->so = true;
            } elseif (preg_match("/^# Created by Websieve version ([0-9])\.([0-9]{1,2})([a-z])?$/", $line, $m)) {
                $this->client = CLIENT_WEBSIEVE;
                $this->version = array('major'=>$m[1], 'minor'=>$m[2], 'bugfix'=>null,
                                       'tag'=>(isset($m[3])) ? $m[3] : null);
                $this->so = true;
            } else {
                $this->so = false;
                $this->mode = 'advanced';
            }
        }
 
        $line = array_shift($lines);
        $startNewBlock = false;
        while (isset($line)) {
            $line = rtrim($line);
            if (substr($line, 0, 18) == '#SmartSieveRule#a:') {
                $serialized = $this->unescapeChars(substr($line, 16));
                $this->rules[] = unserialize($serialized);
            }
            // Legacy metadata format.
            elseif (preg_match("/^ *#rule&&(.*)&&(.*)&&(.*)&&(.*)&&(.*)&&(.*)&&(.*)&&(.*)&&(.*)&&(.*)&&(.*)$/i",
                           $line, $bits)) {
                $rule = array();
                $priority = $bits[1]; // Ignored.
                $rule['status'] = $bits[2];
                $rule['conditions'] = array();
                $rule['actions'] = array();
                $from = $this->unescapeChars($bits[3]);
                if (!empty($from)) {
                    $condition = array();
                    $condition['type'] = TEST_ADDRESS;
                    $condition['header'] = 'from';
                    if (preg_match("/^\s*!/", $from)) {
                        $condition['not'] = true;
                        preg_replace("/^\s*!/", '', $from);
                    }
                    $condition['matchStr'] = $from;
                    if (($bits[8] & REGEX_BIT)) {
                        $condition['matchType'] = MATCH_REGEX;
                    } elseif (preg_match("/\*|\?/", $condition['matchStr']) &&
                        SmartSieve::getConf('websieve_auto_matches') === true) {
                        $condition['matchType'] = MATCH_MATCHES;
                    } else {
                        $condition['matchType'] = MATCH_CONTAINS;
                    }
                    $rule['conditions'][] = $condition;
                }
                $to = $this->unescapeChars($bits[4]);
                if (!empty($to)) {
                    $condition = array();
                    $condition['type'] = TEST_ADDRESS;
                    $condition['header'] = array('to', 'cc');
                    if (preg_match("/^\s*!/", $to)) {
                        $condition['not'] = true;
                        preg_replace("/^\s*!/", '', $to);
                    }
                    $condition['matchStr'] = $to;
                    if (($bits[8] & REGEX_BIT)) {
                        $condition['matchType'] = MATCH_REGEX;
                    } elseif (preg_match("/\*|\?/", $condition['matchStr']) &&
                        SmartSieve::getConf('websieve_auto_matches') === true) {
                        $condition['matchType'] = MATCH_MATCHES;
                    } else {
                        $condition['matchType'] = MATCH_CONTAINS;
                    }
                    $rule['conditions'][] = $condition;
                }
                $subject = $this->unescapeChars($bits[5]);
                if (!empty($subject)) {
                    $condition = array();
                    $condition['type'] = TEST_HEADER;
                    $condition['header'] = 'subject';
                    if (preg_match("/^\s*!/", $subject)) {
                        $condition['not'] = true;
                        preg_replace("/^\s*!/", '', $subject);
                    }
                    $condition['matchStr'] = $subject;
                    if (($bits[8] & REGEX_BIT)) {
                        $condition['matchType'] = MATCH_REGEX;
                    } elseif (preg_match("/\*|\?/", $condition['matchStr']) &&
                        SmartSieve::getConf('websieve_auto_matches') === true) {
                        $condition['matchType'] = MATCH_MATCHES;
                    } else {
                        $condition['matchType'] = MATCH_CONTAINS;
                    }
                    $rule['conditions'][] = $condition;
                }
                $header = $this->unescapeChars($bits[9]);
                $headerMatchStr = $this->unescapeChars($bits[10]);
                if (!empty($header)) {
                    $condition = array();
                    $condition['type'] = TEST_HEADER;
                    $condition['header'] = $header;
                    $condition['matchStr'] = $headerMatchStr;
                    if (preg_match("/^\s*!/", $headerMatchStr)) {
                        $condition['not'] = true;
                        preg_replace("/^\s*!/", '', $headerMatchStr);
                    }
                    if (($bits[8] & REGEX_BIT)) {
                        $condition['matchType'] = MATCH_REGEX;
                    } elseif (preg_match("/\*|\?/", $condition['matchStr']) &&
                        SmartSieve::getConf('websieve_auto_matches') === true) {
                        $condition['matchType'] = MATCH_MATCHES;
                    } else {
                        $condition['matchType'] = MATCH_CONTAINS;
                    }
                    $rule['conditions'][] = $condition;
                }
                $size = $this->unescapeChars($bits[11]);
                if (!empty($size)) {
                    $condition = array();
                    $condition['type'] = TEST_SIZE;
                    $condition['kbytes'] = $size;
                    $condition['gthan'] = ($bits[8] & SIZE_BIT);
                    $rule['conditions'][] = $condition;
                }
                $actionType = $this->unescapeChars($bits[6]);
                $actionArg = $this->unescapeChars($bits[7]);
                if (!empty($actionType)) {
                    $action = array();
                    switch ($actionType) {
                        case ('folder'):
                            $action['type'] = ACTION_FILEINTO;
                            $action['folder'] = $actionArg;
                            break;
                        case ('address'):
                            $action['type'] = ACTION_REDIRECT;
                            $action['address'] = $actionArg;
                            break;
                        case ('reject'):
                            $action['type'] = ACTION_REJECT;
                            $action['message'] = $actionArg;
                            break;
                        case ('discard'):
                            $action['type'] = ACTION_DISCARD;
                            break;
                        case ('custom'):
                            $action['type'] = ACTION_CUSTOM;
                            $action['sieve'] = $actionArg;
                            break;
                    }
                    $rule['actions'][] = $action;
                }
                if ($bits[8] & KEEP_BIT) {
                    $action = array();
                    $action['type'] = ACTION_KEEP;
                    $rule['actions'][] = $action;
                }
                if ($bits[8] & STOP_BIT) {
                    $action = array();
                    $action['type'] = ACTION_STOP;
                    $rule['actions'][] = $action;
                }

                $rule['control'] = ($startNewBlock) ? CONTROL_IF : CONTROL_ELSEIF;
                if ($rule['status'] == 'ENABLED') {
                    $startNewBlock = ($bits[8] & CONTINUE_BIT);
                }
                $rule['matchAny'] = ($bits[8] & ANYOF_BIT);
                // Is this a spacial forward rule?
                if ($this->hasCondition($rule) === false &&
                    count($rule['actions']) > 0 &&
                    $rule['actions'][0]['type'] == ACTION_REDIRECT &&
                    $this->getSpecialRuleId(RULE_TAG_FORWARD) === null) {
                    $rule['special'] = RULE_TAG_FORWARD;
                }
                $this->rules[] = $rule;
            }
            // Legacy vacation values.
            elseif (preg_match("/^ *#vacation&&(.*)&&(.*)&&(.*)&&(.*)/i", $line, $bits)) {
                $rule = array();
                $rule['status'] = ($bits[4] == 'on') ? 'ENABLED' : 'DISABLED';
                $rule['conditions'] = array();
                $rule['actions'] = array();
                $action = array();
                $action['type'] = ACTION_VACATION;
                $action['days'] = $bits[1];
                $action['message'] = $this->unescapeChars($bits[3]);
                $vaddresslist = $this->unescapeChars($bits[2]);
                $vaddresslist = preg_replace("/\"|\s/","", $vaddresslist);
                $action['addresses'] = preg_split("/,/", $vaddresslist);
                $rule['actions'][] = $action;
                $rule['control'] = ($startNewBlock) ? CONTROL_IF : CONTROL_ELSEIF;
                $rule['matchAny'] = 0;
                $rule['special'] = RULE_TAG_VACATION;
                $this->rules[] = $rule;
            }
            elseif (preg_match("/^ *#mode&&(.*)/i", $line, $bits)) {
                if ($bits[1] == 'basic') {
                    $this->mode = 'basic';
                } elseif ($bits[1] == 'advanced') {
                    $this->mode = 'advanced';
                } else {
                    $this->mode = 'advanced';
                }
            }
            $line = array_shift($lines);
        }

        return true;
    }
 
 
   /**
    * Generate and upload the script.
    *
    * @return boolean true on success, false on failure
    */
    function CompileScript($rules_array){
        global $managesieve;
		$version="1.0.0-RC2";
       
        // Generate the sieve content from rules.

        $newscriptbody = array();
 		$this->rules=$rules_array;
 		if(!is_array($this->rules)){
 			return false;
 			writelogs("sieve: rules_array is not an array...",__CLASS__.'/'.__FUNCTION__,__FILE__);
 			}
 			
 		
 		reset($this->rules);
        foreach ($this->rules as $rule) {
            $newscriptbody[]= $this->getSieveForRule($rule);
            
        }
 
        // Generate script header and add a "require" line if needed.
  		writelogs("sieve: Generate heads",__CLASS__.'/'.__FUNCTION__,__FILE__);
        $newscripthead ="#Mail filter rules from artica\n";
        $newscripthead=$newscripthead."#Generated by artica using SmartSieve $version ".date('Y/m/d H:i:s')."\n";
 
        $newrequire = '';
        $started = false;
        foreach ($this->extensions as $ext=>$used) {
            if ($used == true) {
                $newrequire .= ($started) ? ',' : 'require [';
                $newrequire .= sprintf("\"%s\"", $ext);
                $started = true;
            }
        }
        $newrequire .= (strlen($newrequire) > 0) ? "];\n\n" : '';
 
        // Generate an encoded version of script content.
 		writelogs("sieve: Generate foot",__CLASS__.'/'.__FUNCTION__,__FILE__);
        $newscriptfoot = "##PSEUDO script start\n";
        foreach ($this->rules as $rule) {
            // Add rule to foot if status != deleted. This is how we delete a rule.
            if ($rule['status'] != 'DELETED') {
                $newscriptfoot .= '#SmartSieveRule#' . $this->escapeChars(serialize($rule)) . "\n";
            }
        }
        $newscriptfoot .= sprintf("#mode&&%s\n", $this->mode);
 
        // Put the script content together.
        $newscript = $newscripthead . $newrequire . implode("",$newscriptbody) . $newscriptfoot;
		
        // But if we're in direct edit mode, content comes direct from the user.
        if ($this->mode == 'advanced') {
            $newscript = $newscripthead . $this->removeEncoding()  . $newscriptfoot;
        }
		writelogs("sieve: \---$newscript\--",__CLASS__.'/'.__FUNCTION__,__FILE__);
        $this->content = $newscript;
      //  file_put_contents("/tmp/sieve.txt",$newscript);
        // All went well.
        return $newscript;
    }


   /**
    * Generate sieve for a filter rule.
    *
    * @param array $rule The rule to generate sieve from
    * @return string The sieve for the rule
    */
    function getSieveForRule($rule)
    {
        $newruletext =array();
        static $startNewBlock = true;
	
        // Generate sieve if rule is enabled.
        if (!empty($rule) && $rule['status'] == 'ENABLED') {

            // Conditions
			
            $started = false;
			
            if ($this->hasCondition($rule)) {
            	
                $newruletext[]= sprintf("%sif %s (",
                    ($startNewBlock || $rule['control'] == CONTROL_IF) ? '' : 'els',
                    ($rule['matchAny']) ? 'anyof' : 'allof');
                foreach ($rule['conditions'] as $condition) {
                    $newruletext[]= ($started) ? ', ' : '';
                    if ($condition['type'] == TEST_ADDRESS) {
                        if ($condition['matchType'] == MATCH_REGEX) {
                            $this->extensions['regex'] = true;
                        }
                        $newruletext[]= sprintf("%saddress %s %s \"%s\"",
                            (!empty($condition['not'])) ? 'not ' : '',
                            $condition['matchType'],
                            (is_array($condition['header'])) ? sprintf('["%s"]', implode('","', $condition['header'])) : sprintf('"%s"', $condition['header']),
                            $condition['matchStr']);
                    } elseif ($condition['type'] == TEST_HEADER) {
                        if ($condition['matchType'] == MATCH_REGEX) {
                            $this->extensions['regex'] = true;
                        }
                       $newruletext[]= sprintf("%sheader %s \"%s\" \"%s\"",
                            (!empty($condition['not'])) ? 'not ' : '',
                            $condition['matchType'], $condition['header'], $condition['matchStr']);
                    } elseif ($condition['type'] == TEST_SIZE) {
                        $newruletext[]= sprintf("size %s %sK",
                            ($condition['gthan']) ? ':over' : ':under', $condition['kbytes']);
                    } elseif ($condition['type'] == TEST_BODY) {
                        $this->extensions['body'] = true;
                        if ($condition['matchType'] == MATCH_REGEX) {
                            $this->extensions['regex'] = true;
                        }
                        $newruletext[]= sprintf("%sbody %s %s\"%s\"",
                                (!empty($condition['not'])) ? 'not ' : '',
                                $condition['matchType'],
                                (!empty($condition['transform'])) ? sprintf("%s ", $condition['transform']) : '',
                                $condition['matchStr']);
                    }
                    $started = true;
                }
                
                $newruletext[]= ") {\n";
            }

            // Actions
			
            $custom = false;
            foreach ($rule['actions'] as $action) {
            	writelogs("sieve: Parsing action type={$action['type']}",__CLASS__.'/'.__FUNCTION__,__FILE__);
                switch ($action['type']) {
                    case (ACTION_FILEINTO):
                        $text= sprintf("%sfileinto \"%s\";\n",$this->hasCondition($rule) ? "\t" : '',$action['folder']);
                        $newruletext[]=$text;
                         writelogs("sieve:ACTION_FILEINTO \"$text\"",__CLASS__.'/'.__FUNCTION__,__FILE__);
                        $this->extensions['fileinto'] = true;
                        break;
                    case (ACTION_REJECT):
                    	writelogs("ACTION_REJECT",__CLASS__.'/'.__FUNCTION__,__FILE__);
                        $newruletext[]= sprintf("%sreject text:\n%s\n.\n;\n",$this->hasCondition($rule) ? "\t" : '',$action['message']);
                        $this->extensions['reject'] = true;
                        break;
                    case (ACTION_REDIRECT):
                    	writelogs("ACTION_REDIRECT",__CLASS__.'/'.__FUNCTION__,__FILE__);
                        $newruletext[]= sprintf("%sredirect \"%s\";\n",$this->hasCondition($rule) ? "\t" : '',$action['address']);
                        break;
                    case (ACTION_DISCARD):
                    	writelogs("ACTION_DISCARD",__CLASS__.'/'.__FUNCTION__,__FILE__);
                        $newruletext[]= sprintf("%sdiscard;\n",$this->hasCondition($rule) ? "\t" : '');
                        break;
                    case (ACTION_KEEP):
                    	writelogs("ACTION_KEEP",__CLASS__.'/'.__FUNCTION__,__FILE__);
                        $newruletext[]= sprintf("%skeep;\n",$this->hasCondition($rule) ? "\t" : '');
                        break;
                    case (ACTION_STOP):
                    	writelogs("ACTION_STOP",__CLASS__.'/'.__FUNCTION__,__FILE__);
                        $newruletext[]= sprintf("%sstop;\n",$this->hasCondition($rule) ? "\t" : '');
                        break;
                    case (ACTION_VACATION):
                    	writelogs("ACTION_VACATION",__CLASS__.'/'.__FUNCTION__,__FILE__);
                        $addstr = '';
                        if (!empty($action['addresses'])) {
                            $addstr .= ':addresses [';
                            for ($i=0; $i<count($action['addresses']); $i++) {
                                $addstr .= sprintf("%s\"%s\"", ($i != 0) ? ', ' : '',$action['addresses'][$i]);
                            }
                            $addstr .= '] ';
                        }
                        $newruletext[]= sprintf("%svacation %s%stext:\n%s\n.\n;\n\n",
                            $this->hasCondition($rule) ? "\t" : '',
                            (!empty($action['days'])) ? sprintf(":days %s ", $action['days']) : '',
                            (!empty($addstr)) ? $addstr : '', $action['message']);
                        $this->extensions['vacation'] = true;
                        break;
                    case (ACTION_ADDFLAG):
                        $text= sprintf("%saddflag \"%s\";\n",$this->hasCondition($rule) ? "\t" : '',$action['flag']);
                        $newruletext[]=$text;
                        writelogs("sieve:ACTION_ADDFLAG \"$newruletext\"",__CLASS__.'/'.__FUNCTION__,__FILE__);
                        $this->extensions['imapflags'] = true;
                        break;
                    case (ACTION_NOTIFY):
                    	writelogs("ACTION_NOTIFY",__CLASS__.'/'.__FUNCTION__,__FILE__);
                        $newruletext[]= sprintf("%snotify :method \"%s\" :options \"%s\" :message \"%s\";\n",$this->hasCondition($rule) ? "\t" : '',$action['method'], $action['options'], $action['message']);
                        $this->extensions['notify'] = true;
                        break;
                    case (ACTION_CUSTOM):
                    	writelogs("ACTION_CUSTOM",__CLASS__.'/'.__FUNCTION__,__FILE__);
                    	unset($newruletext);
                        $newruletext[] = $action['sieve'];
                        $custom = true;
                        if (stripos($action['sieve'], ':regex') !== false) {
                            $this->extensions['regex'] = true;
                        } if (stripos($action['sieve'], 'reject') !== false) {
                            $this->extensions['reject'] = true;
                        } if (stripos($action['sieve'], 'vacation') !== false) {
                            $this->extensions['vacation'] = true;
                        } if (stripos($action['sieve'], 'notify') !== false) {
                            $this->extensions['notify'] = true;
                        } if (stripos($action['sieve'], 'addflag') !== false ||
                              stripos($action['sieve'], 'setflag') !== false ||
                              stripos($action['sieve'], 'removeflag') !== false) {
                            $this->extensions['imapflags'] = true;
                        }
                        continue 2;
                        break;
                    default:writelogs("sieve: unable to understand {$action['type']}",__CLASS__.'/'.__FUNCTION__,__FILE__);break;
                }
                
                writelogs("sieve:Array of ".count($newruletext)." rows",__CLASS__.'/'.__FUNCTION__,__FILE__);
            }

            if(!$custom){writelogs("sieve: hasCondition:".$this->hasCondition($rule). " custom=FALSE",__CLASS__.'/'.__FUNCTION__,__FILE__);}
            if ($this->hasCondition($rule) && $custom == false) {
                $newruletext[]= "}\n";
				writelogs("sieve: hasCondition: close the function",__CLASS__.'/'.__FUNCTION__,__FILE__);			
            }
            
            $newruletext[]= "\n";
			
            // Should next rule start with an "if..."?
            $startNewBlock = false;
            if ($this->hasCondition($rule) == false) {
            	writelogs("sieve: hasCondition: start new block",__CLASS__.'/'.__FUNCTION__,__FILE__);
                $startNewBlock = true;
            }

        }
        writelogs("implode the Array of ".count($newruletext)." rows",__CLASS__.'/'.__FUNCTION__,__FILE__);
        //print_r($newruletext);
        $imploded=implode("",$newruletext);
        writelogs("sieve: rule imploded=$imploded",__CLASS__.'/'.__FUNCTION__,__FILE__);
        return $imploded;
    }


   /**
    * Return the sieve script content with any encoded lines stripped out.
    *
    * @return string The script content minus encoded lines
    */
    function removeEncoding()
    {
        global $script;
        $raw = '';
        $encs = array('^ *##PSEUDO','^ *#rule','^ *#vacation','^ *#mode',
                      '^ *# ?Mail(.*)rules for','^ *# ?Created by Websieve',
                      '^ *#Generated (.+) SmartSieve');
        $lines = array();
        $lines = explode("\n", $script->content);
        foreach ($lines as $line){
            foreach ($encs as $enc){
                if (preg_match("/$enc/", $line))
                    continue 2;
            }
            $raw .= $line . "\n";
        }
        return $raw;
    }

   /**
    * Make a string safe for the encoded index. Replace CRLFs and & chars.
    *
    * @param string $string The string to make safe
    * @return string The safe string
    */
    function escapeChars($string)
    {
        $string = preg_replace('/\\\\/', '\\\\\\', $string);
        $string = preg_replace("/\r\n/", "\\n", $string);
        $string = preg_replace("/&/", "\&", $string);
        $string = preg_replace("/\|/", "\|", $string);
        return $string;
    }

   /**
    * Unescape a string made safe by escapeChars().
    *
    * @param string $string The string to unescape
    * @return string The unescaped string
    */
    function unescapeChars($string)
    {
        $string = preg_replace("/\\\\n/", "\r\n", $string);
        $string = preg_replace("/\\\&/", "&", $string);
        // 1.0.0-RC2 and newer escape '\' and '|'.
        if ($this->checkVersion(1, 0, 0, 'RC2') >= 0) {
            $string = preg_replace("/\\\\\|/", "|", $string);
            $string = preg_replace('/\\\\\\\\/', '\\', $string);
        }
        return $string;
    }

   /**
    * Check what version of SmartSieve this script was created by.
    *
    * @param integer $major Major version number
    * @param integer $minor Minor version number
    * @param integer $bugfix Bugfix version number
    * @param string $tag, Version tag
    * @return integer < 0 if version is earlier, 0 if the same, or > 0 if newer
    */
    function checkVersion($major=null, $minor=null, $bugfix=null, $tag=null)
    {
        // If called without parameters use current version.
        if (is_null($major)) {
            include_once SmartSieve::getConf('lib_dir', 'lib') . '/version.php';
            list($major, $minor, $bugfix) = explode('.', VERSION);
            if (strpos($bugfix, '-') !== false) {
                list($bugfix, $tag) = explode('-', $bugfix);
            }
        }
        $scriptVer = sprintf("%s%s%s%s",
                             (isset($this->version['major'])) ? $this->version['major'] : '',
                             (isset($this->version['minor'])) ? $this->version['minor'] : '',
                             (isset($this->version['bugfix'])) ? $this->version['bugfix'] : '',
                             (isset($this->version['tag'])) ? $this->version['tag'] : 'ZZZ');
        $checkVer = sprintf("%s%s%s%s", $major, $minor, $bugfix, (isset($tag)) ? $tag : 'ZZZ');
        return strcmp($scriptVer, $checkVer);
    }

   /**
    * Does rule have a condition.
    *
    * @param array $rule The rule to check
    * @return boolean True if rule has a condition, false if not
    */
    function hasCondition($rule)
    {
        $custom = null;
        // A custom rule might have a condition in it.
        if(is_array($rule['actions'])){
        foreach ($rule['actions'] as $action) {
            if ($action['type'] == ACTION_CUSTOM) {
                $custom = $action;
            }
        }
        }
        // If rule has conditions, or is a custom rule with a condition, return true.
        if ((!empty($rule['conditions']) && !$custom) ||
            ($custom && preg_match("/^ *(els)?if/i", $custom['sieve']))) {
            return true;
        }
        return false;
    }

   /**
    * Change the order of filter rules.
    *
    * @param integer $subject Array index of the rule to move
    * @param integer $target Array index to move rule to
    * @return boolean True if successful, false if not
    */
    function changeRuleOrder($subject, $target)
    {
        if ($target > (count($this->rules)-1)) {
            $target = count($this->rules)-1;
        }
        $newrules = array();
        if (isset($this->rules[$subject]) &&
            isset($this->rules[$target]) && $subject != $target) {
            for ($i=0; $i<count($this->rules); $i++) {
                if ($i == $subject) {
                    // Ignore.
                } else {
                    if ($i === $target) {
                        if ($subject < $target) { // Add after.
                            $newrules[] = $this->rules[$i];
                            $newrules[] = $this->rules[$subject];
                        } else {                  // Add before.
                            $newrules[] = $this->rules[$subject];
                            $newrules[] = $this->rules[$i];
                        }
                    } else {
                        $newrules[] = $this->rules[$i];
                    }
                }
            }
            $this->rules = $newrules;
        }
        return true;
    }

   /**
    * Add a new filter rule.
    *
    * @param array $rule The rule to add
    * @param integer $position Optional array position at which to add rule
    * @return integer Array index of added rule
    */
    function addRule($rule, $position=null)
    {
        if (!is_null($position) && is_int($position) &&
            $position < count($this->rules)) {
            $newrules = array();
            for ($i=0; $i<count($this->rules); $i++) {
                if ($i == $position) {
                    $newrules[] = $rule;
                }
                $newrules[] = $this->rules[$i];
            }
            $this->rules = $newrules;
            return $position;
        }
        return array_push($this->rules, $rule) - 1;
    }

   /**
    * Save an existing filter rule.
    *
    * @param array $rule The rule to save
    * @param integer $position Array index of rule
    * @return integer Array index of added rule
    */
    function saveRule($rule, $position)
    {
        if (!isset($this->rules[$position])) {
            return $this->addRule($rule);
        }
        $this->rules[$position] = $rule;
        return $position;
    }

   /**
    * Delete a filter rule.
    *
    * @param integer $rid Array index of the rule to delete
    * @return boolean True if successful, false if not
    */
    function deleteRule($rid)
    {
        if (isset($this->rules[$rid])) {
            unset($this->rules[$rid]);
            $this->rules = array_values($this->rules);
            return true;
        }
        return false;
    }

   /**
    * Get a filter rule.
    *
    * @param integer $rid Array index of the rule to delete
    * @return mixed Rule array if it exists, or null otherwise.
    */
    function getRule($id)
    {
        return (isset($this->rules[$id])) ? $this->rules[$id] : null;
    }

   /**
    * Get a special rule (vacation, whitelist etc).
    *
    * @param string $tag Special rule tag, one of RULE_TAG_* contants
    * @return mixed Array index if it exists, or null otherwise.
    */
    function getSpecialRuleId($tag)
    {
        for ($i=0; $i<count($this->rules); $i++) {
            if (!empty($this->rules[$i]['special']) && $this->rules[$i]['special'] == $tag) {
                return $i;
            }
        }
        return null;
    }

   /**
    * Get the script name.
    *
    * @return string The name of the script as it appears on the server
    */
    function getName()
    {
        return $this->name;
    }

   /**
    * Is filter rule enabled.
    *
    * @param integer $id The array index of rule to check
    * @return boolean True if rule if enabled, false if not
    */
    function isRuleEnabled($id)
    {
        if (isset($this->rules[$id]) &&
            $this->rules[$id]['status'] == 'ENABLED') {
            return true;
        }
        return false;
    }
    
    
function getSummary($rule){
    
    static $useif = true;
    $started = 0;
    $andor = sprintf(" %s ", ($rule['matchAny']) ? sprintf('OR') : sprintf('AND'));

    if ($this->hasCondition($rule) == false) {
        $complete = sprintf("[%s] ", sprintf('Unconditional'));
    } elseif ($useif || $rule['control'] == CONTROL_IF) {
        $complete = sprintf("%s ", sprintf('IF'));
    } else {
        $complete = sprintf("%s ", sprintf('ELSE IF'));
    }
if(is_array($condition)){
    foreach ($rule['conditions'] as $condition) {
        $complete .= ($started) ? $andor : '';
        if ($condition['type'] == TEST_ADDRESS) {
            $match = $this->getMatchType($condition['matchType'], isset($condition['not']) ? $condition['not'] : false);
            if ($condition['header'] == 'from') {
                $complete .= sprintf("'From:' %s '%s'",
                    $match, $this->utf8Decode($condition['matchStr']));
                $started = 1;
            } elseif ($condition['header'] == 'to') {
                $complete .= sprintf("'To:' %s '%s'",
                    $match, $this->utf8Decode($condition['matchStr']));
                $started = 1;
            } elseif ($condition['header'] == array('to', 'cc')) {
                $complete .= sprintf("'To:' or 'Cc:' %s '%s'",
                    $match, $this->utf8Decode($condition['matchStr']));
                $started = 1;
            } else {
                $complete .= sprintf("'%s' %s '%s'", $condition['header'],
                    $match, $this->utf8Decode($condition['matchStr']));
                $started = 1;
            }
        }
        if ($condition['type'] == TEST_HEADER) {
            $match = $this->getMatchType($condition['matchType'], isset($condition['not']) ? $condition['not'] : false);
            if ($condition['header'] == 'subject') {
                $complete .= sprintf("'Subject:' %s '%s'",
                    $match, $this->utf8Decode($condition['matchStr']));
            } else {
                $complete .= sprintf("'%s' %s '%s'",
                    $this->utf8Decode($condition['header']), $match,
                    $this->utf8Decode($condition['matchStr']));
            }
            $started = 1;
        }
        if ($condition['type'] == TEST_SIZE) {
            $complete .= @sprintf("message %s '%sKB'", array(($condition['gthan']) ? @sprintf('greater than') : @sprintf('less than'),$condition['kbytes']));
            $started = 1;
        }
        if ($condition['type'] == TEST_BODY) {
            $match = $this->getMatchType($condition['matchType'], isset($condition['not']) ? $condition['not'] : false);
            $complete .= sprintf("message body %s '%s'", array(
                $match, $this->utf8Decode($condition['matchStr'])));
            $started = 1;
        }
    }
}
    if ($this->hasCondition($rule)) {
        $complete .= sprintf(" %s ", sprintf('THEN'));
    }
    $started = false;
   if(is_array($rule['actions'])){
    foreach ($rule['actions'] as $action) {
        if ($started) {
            $complete .= sprintf(" %s ", sprintf('AND'));
        }
        switch ($action['type']) {
            case (ACTION_FILEINTO):
                $complete .= sprintf("%s '%s'", sprintf('file into'),
                                     $this->mutf7Decode($action['folder']));
                break;
            case (ACTION_REDIRECT):
                $complete .= sprintf("%s '%s'", sprintf('forward to'),
                                     $this->utf8Decode($action['address']));
                break;
            case (ACTION_REJECT):
                $complete .= sprintf("%s '%s'", sprintf('reject'),
                                     $this->utf8Decode($action['message']));
                break;
            case (ACTION_DISCARD):
                $complete .= sprintf('discard');
                break;
            case (ACTION_KEEP):
                $complete .= sprintf('Keep a copy');
                break;
            case (ACTION_STOP):
                $complete .= sprintf('Stop processing');
                break;
            case (ACTION_VACATION):
                $complete .= sprintf('Respond');
                if (!empty($action['addresses']) && is_array($action['addresses'])) {
                    $complete .= sprintf(" %s ", sprintf('to mail sent to'));
                    $first = true;
                    foreach ($action['addresses'] as $addr) {
                        $complete .= ($first) ? '' : ', ';
                        $complete .= $this->utf8Decode($addr);
                        $first = false;
                    }
                }
                $complete .= (!empty($action['days'])) ? sprintf(" %s ",sprintf("every %s days",$action['days'])) : '';
                $complete .= sprintf(" %s",sprintf('with message "%s"',$this->utf8Decode($action['message'])));
                break;
            case (ACTION_ADDFLAG):
                $complete .= sprintf('set the "%s" flag', $action['flag']);
                break;
            case (ACTION_NOTIFY):
                if ($action['method'] == 'mailto') {
                    $complete .= sprintf('send email notification to %s "%s"',$action['options'], $action['message']);
                } elseif ($action['method'] == 'sms') {
                    $complete .= sprintf('send SMS notification to %s "%s"',$action['options'], $action['message']);
                } else {
                    $complete .= sprintf('send notification to %s "%s"',$action['options'], $action['message']);
                }
                break;
            case (ACTION_CUSTOM):
                // Scrap the above and just display the custom text.
                $complete = sprintf("[%s] %s", sprintf('Custom Rule'),$this->utf8Decode($action['sieve']));
                continue 2;
                break;
        }
        $started = true;
    }
   }
    if ($rule['status'] == 'ENABLED') {
        $useif = false;
        if ($this->hasCondition($rule) == false) {
            $useif = true;
        }
    }
    return htmlspecialchars($complete);
}

    function utf8Decode($string){
        $charset = $this->charset;

        if (strtolower($charset) == 'utf-8') {
            return $string;
        }

        /* Try iconv. */
        if (extension_loaded('iconv')) {
            $recoded = @iconv('UTF-8', $charset . '//TRANSLIT', $string);
            if ($recoded) {
                return $recoded;
            }
        }

        /* Try mbstring. */
        if (extension_loaded('mbstring')) {
            $recoded = @mb_convert_encoding($string, $charset, 'UTF-8');
            if ($recoded) {
                return $recoded;
            }
        }

        /* If all else fails, use utf8_decode(). If $string contains
         * non-ISO-8859-1 characters, they will not be decoded correctly. */
        return utf8_decode($string);
    }
    
    function text($string = '', $args = array()){
		return $string;
    }  

    
function getMatchType($matchType, $not=false){
    $translated = $this->text('contains');
    switch ($matchType) {
        case (MATCH_IS):
            $translated = ($not) ? $this->text('is not') : $this->text('is');
            break;
        case (MATCH_MATCHES):
            $translated = ($not) ? $this->text('does not match') : $this->text('matches');
            break;
        case (MATCH_REGEX):
            $translated = ($not) ? $this->text('does not match regexp') : $this->text('matches regexp');
            break;
        case (MATCH_CONTAINS):
        default:
            $translated = ($not) ? $this->text('does not contain') : $this->text('contains');
            break;
    }
    return $translated;
}
   function mutf7Decode($string){
        $charset = $this->charset;

        /* if we're using the ISO-8859-1 charset, we can just use imap_utf7_decode(). */
        if (strtolower($charset) == 'iso-8859-1' || strtolower($charset) == 'us-ascii') {
            if (extension_loaded('imap')) {
                return imap_utf7_decode($string);
            }
        }

        /* try mbstring if available. */
        if (extension_loaded('mbstring')) {
            $decoded = @mb_convert_encoding($string, $charset, 'UTF7-IMAP');
            if ($decoded) {
                return $decoded;
            }
        }

        /* try iconv if available. use transliterations to avoid warnings about 
         * incompatible characters. also, add extra ascii char to avoid iconv bug. */
        if (extension_loaded('iconv')) {
            /* convert the modified UTF-7 string to UTF-7. */
            $utf7 = $this->_modifiedToPlainUTF7($string);
            $decoded = @iconv('UTF-7', $charset . '//TRANSLIT', $utf7 . "\0");
            if ($decoded) {
                return $decoded;
            }
        }

        /* if all else fails, use imap_utf7_decode(). If mailbox name includes 
         * non-ISO-8859-1 characters, they will not be decoded correctly. */
        if (extension_loaded('imap')) {return imap_utf7_decode($string);}

        return $string;
    }    
    
    function _modifiedToPlainUTF7($string){
        $utf7 = '';
        $base64 = false;
        for ($i = 0; $i < strlen($string); $i++) {
            if ($string[$i] == "&") {
                /* Convert the shift char '&' to '+'.
                   Literal '&' will be encoded as '&-'. */
                if ($string[$i+1] == "-") {
                    $utf7 .= "&"; // '&-' -> '&'
                    $i++;
                }
                else {
                    $utf7 .= "+"; // '&' -> '+'
                    $base64 = true;
                }
            }
            elseif ($string[$i] == "-" && $base64) {
                /* shift back to us-ascii. */
                $base64 = false;
            }
            else {
                if ($base64 && $string[$i] == ",") {
                    $utf7 .= "/"; // ',' -> '/'
                }
                elseif (!$base64 && $string[$i] == "+") {
                    $utf7 .= "+-"; // '+' -> '+-'
                }
                else {
                    $utf7 .= $string[$i];
                }
            }
        }
        return $utf7;
    }    


}

?>
