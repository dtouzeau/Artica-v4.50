<bind-address>IP address to bind to</bind-address>
<innodb_additional_mem_pool_size>INNODB additional memory pool size</innodb_additional_mem_pool_size>
<innodb_additional_mem_pool_size_text>Stores the internal data structure.[br]
 Make sure it is big enough to store data about all your InnoDB tables (you will see warnings in the error log if the server is using OS memory instead).</innodb_additional_mem_pool_size_text>
<innodb_buffer_pool_size>INNODB buffer pool size</innodb_buffer_pool_size>
<innodb_buffer_pool_size_text>Enquanto o tamanho do buffer chave é a vari%C3¡vel a visar para as tabelas MyISAM, para as tabelas InnoDB, é o tamanho do pool de buffer inodb [br].
Mais uma vez, quer isto o mais alto poss%C3%ADvel para minimizar o uso lento do disco [br].
Num servidor MySQL dedicado a executar tabelas InnoDB, pode configurar isto até 80% da mem%C3%B3ria total dispon%C3%ADvel.</innodb_buffer_pool_size_text>
<innodb_lock_wait_timeout>innodb lock wait timeout</innodb_lock_wait_timeout>
<innodb_lock_wait_timeout_text>
The timeout in seconds an InnoDB transaction may wait for a row lock before giving up.[br]
The default value is 50 seconds.[br]
A transaction that tries to access a row that is locked by another InnoDB transaction will hang for at most this many seconds before issuing the following error:
[b]ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction[/b]
When a lock wait timeout occurs, the current statement is not executed.[br]
The current transaction is not rolled back.[br] (Until MySQL 5.0.13 InnoDB rolled back the entire transaction if a lock wait timeout happened). 
</innodb_lock_wait_timeout_text>
<innodb_log_buffer_size>Tamanho do tamp%C3£o de registo INNODB</innodb_log_buffer_size>
<innodb_log_buffer_size_text>
The size in bytes of the buffer that InnoDB uses to write to the log files on disk.[br]
The default value is 1MB. Sensible values range from 1MB to 8MB.[br]
A large log buffer enables large transactions to run without a need to write the log to disk before the transactions commit.[br]
Thus, if you have big transactions, making the log buffer larger saves disk I/O. 
</innodb_log_buffer_size_text>
<innodb_log_file_size>innodb log file size</innodb_log_file_size>
<innodb_log_file_size_text>O tamanho em bytes de cada ficheiro de registo num grupo de registo [br].
O tamanho combinado dos ficheiros de registo deve ser inferior a 4GB[br].
O valor por defeito é de 5MB.[br]
Os valores sens%C3%ADveis variam de 1MB a 1/N-ésimo do tamanho do grupo tamp%C3£o, onde N é o n%C3%BAmero de ficheiros de registo no grupo [br].
Quanto maior for o valor, menos actividade de descarga do ponto de controlo é necess%C3¡ria na reserva, poupando a E/S do disco. Mas ficheiros de registo maiores significam também que a recuperaç%C3£o é mais lenta no caso de uma falha.</innodb_log_file_size_text>
<join_buffer_size>JOIN buffer size</join_buffer_size>
<join_buffer_size_text>
The size of the buffer that is used for plain index scans, range index scans, and joins that do not use indexes and thus perform full table scans.[br]
 Normally, the best way to get fast joins is to add indexes.[br]
Increase the value of join_buffer_size to get a faster full join when adding indexes is not possible.[br]
One join buffer is allocated for each full join between two tables.[br]
For a complex join between several tables for which indexes are not used, multiple join buffers might be necessary.</join_buffer_size_text>
<key_buffer>KEY buffer</key_buffer>
<key_buffer_size>KEY buffer size</key_buffer_size>
<key_buffer_size_text>Os blocos de %C3%ADndice para as tabelas MyISAM s%C3£o protegidos e partilhados por todos os fios [br].
O tamanho do tamp%C3£o é o tamanho do tamp%C3£o utilizado para os blocos de %C3%ADndices.[br]
O tamp%C3£o de chave também é conhecido como a cache da chave[br].
Pode aumentar o valor para obter um melhor tratamento de %C3%ADndice para todas as leituras e escritas m%C3%BAltiplas;[br]
num sistema cuja funç%C3£o prim%C3¡ria é executar o MySQL utilizando o motor de armazenamento MyISAM, 25% da mem%C3%B3ria total da m%C3¡quina é um valor aceit%C3¡vel para esta vari%C3¡vel[br].
No entanto, deve estar ciente de que, se tornar o valor demasiado grande (por exemplo, mais de 50% da mem%C3%B3ria total da m%C3¡quina),
o seu sistema pode começar a paginar e tornar-se extremamente lento</key_buffer_size_text>
<key_buffer_text>Set key_buffer to 5 - 50% of your RAM depending on how much you use MyISAM tables, but keep key_buffer_size + InnoDB buffer pool size under 80% of your RAM
</key_buffer_text>
<max_allowed_packet>MAX Allowed packet</max_allowed_packet>
<max_allowed_packet_text>The maximum size of one packet or any generated/intermediate string</max_allowed_packet_text>
<max_connections>Conex%C3µes m%C3¡ximas</max_connections>
<max_connections_text>The number of simultaneous client connections allowed. By default, this is 151</max_connections_text>
<myisam_sort_buffer_size>MyISAM SORT buffer size</myisam_sort_buffer_size>
<myisam_sort_buffer_size_text>
The size of the buffer that is allocated when sorting MyISAM indexes during a REPAIR TABLE or when creating indexes with CREATE INDEX or ALTER TABLE.
</myisam_sort_buffer_size_text>
<mysql_settings>Parâmetros do MySQL</mysql_settings>
<net_buffer_length>NET buffer length</net_buffer_length>
<net_buffer_length_text>The initial size of the buffer for client/server communication.</net_buffer_length_text>
<query_cache_limit>QUERY cache limit</query_cache_limit>
<query_cache_limit_text>Don't cache results that are larger than this number of bytes. The default value is 1MB</query_cache_limit_text>
<query_cache_size>QUERY cache size</query_cache_size>
<query_cache_size_text>The amount of memory allocated for caching query results.[br]
 The default value is 0, which disables the query cache.[br]
 The allowable values are multiples of 1024; other values are rounded down to the nearest multiple</query_cache_size_text>
<read_buffer_size>Tamanho do buffer READ</read_buffer_size>
<read_buffer_size_text>Cada linha que faz uma varredura sequencial atribui um buffer deste tamanho (em bytes) para cada tabela que escaneia [br].
Se fizer muitos scans sequenciais, poder%C3¡ querer aumentar este valor, que por defeito é de 131072. O valor desta vari%C3¡vel deve ser um m%C3%BAltiplo de 4KB.[br]
Se for definido para um valor que n%C3£o seja um m%C3%BAltiplo de 4KB, o seu valor ser%C3¡ arredondado para o m%C3%BAltiplo mais pr%C3%B3ximo de 4KB.</read_buffer_size_text>
<read_rnd_buffer_size>Tamanho do buffer READ rnd</read_rnd_buffer_size>
<read_rnd_buffer_size_text>Usado ap%C3%B3s uma ordenaç%C3£o, quando se lêem as linhas por ordem ordenada [br].
Se usar muitas consultas com ORDER BY, aumentar isto pode melhorar o desempenho [br].
Lembre-se que, ao contr%C3¡rio do tamanho da chave e do cache da tabela, este buffer é atribu%C3%ADdo para cada linha [br].
O seu tamanho por defeito é o mesmo que o tamanho do tamp%C3£o de leitura, que por defeito é de 128KB.[br]
Uma regra geral é atribuir 1KB para cada 1MB de mem%C3%B3ria no servidor, por exemplo 3MB numa m%C3¡quina com 3GB de mem%C3%B3ria.</read_rnd_buffer_size_text>
<skip-external-locking>External locking</skip-external-locking>
<skip-external-locking_text>
External locking is the use of file system locking to manage contention for database tables by multiple processes.[br]
External locking is used in situations where a single process such as the MySQL server cannot be assumed to be the only process that requires access to tables
</skip-external-locking_text>
<sort_buffer>SORT buffer</sort_buffer>
<sort_buffer_size>SORT buffer size</sort_buffer_size>
<sort_buffer_size_text>Each thread that needs to do a sort allocates a buffer of this size. Increase this value for faster ORDER BY or GROUP BY operations</sort_buffer_size_text>
<sort_buffer_text>
The sort_buffer is very useful for speeding up myisamchk operations (which is why it is set much higher for that purpose in the default configuration files), 
but it can also be useful everyday when performing large numbers of sorts.[br]
Successfully upped it to 9MB on a 3GB server running quite a few sorts.
</sort_buffer_text>
<table_cache>tmp TABLE size</table_cache>
<table_cache>tmp TABLE size</table_cache>
<table_open_cache>TABLE open cache</table_open_cache>
<table_open_cache_text>The number of open tables for all threads.[br] Increasing this value increases the number of file descriptors that mysqld requires</table_open_cache_text>
<thread_cache_size>THREAD Cache size</thread_cache_size>
<thread_cache_size_text>How many threads the server should cache for reuse.[br]
 When a client disconnects, the client's threads are put in the cache if there are fewer than thread_cache_size threads there.[br]
Requests for threads are satisfied by reusing threads taken from the cache if possible, and only when the cache is empty is a new thread created.[br]
This variable can be increased to improve performance if you have a lot of new connections.[br]
(Normally, this doesn't provide a notable performance improvement if you have a good thread implementation.)
</thread_cache_size_text>
<tmp_table_size>INNODB buffer pool size</tmp_table_size>
<tmp_table_size_text>
This variable determines the maximum size for a temporary table in memory.[br]
If the table becomes too large, a MYISAM table is created on disk.[br]
Try to avoid temporary tables by optimizing the queries where possible, 
but where this is not possible, try to ensure temporary tables are always stored in memory.[br]
Watching the processlist for queries with temporary tables that take too long to resolve can give you an early warning that 
tmp table size needs to be upped.[br]
Be aware that memory is also allocated per-thread.[br]
An example where upping this worked for more was a server where upped this from 32MB (the default) to 64MB with immediate effect.[br]
The quicker resolution of queries resulted in less threads being active at any one time, with all-round benefits for the server, and available memory.
</tmp_table_size_text>
<wait_timeout>Wait timeout</wait_timeout>
<wait_timeout_text>O n%C3%BAmero de segundos que o servidor espera por actividade numa conex%C3£o n%C3£o interactiva antes de a fechar[br].
Este timeout aplica-se apenas a conex%C3µes de ficheiros TCP/IP e Unix, e n%C3£o a conex%C3µes feitas usando tubos nomeados, ou mem%C3%B3ria partilhada.</wait_timeout_text>
